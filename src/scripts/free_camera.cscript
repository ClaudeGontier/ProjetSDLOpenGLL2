NEW_SCRIPT(free_camera)
	PARAMS_COUNT(2);

	int *movable = &node->params[0].i;
	int *active = &node->params[1].i;


	Camera *c = (Camera*) node->object;

	if (glm_vec3_norm2(c->targetPos) == 0) glm_vec3_copy(node->pos, c->targetPos);
	if (glm_vec3_norm2(c->targetRot) == 0) glm_vec3_copy(node->rot, c->targetRot);

	if (*movable) {
		c->targetRot[1] -= (f32) (input->mouse.x - input->mouse.lastX) * delta * 100.0;
		c->targetRot[0] -= (f32) (input->mouse.lastY - input->mouse.y) * delta * 100.0;
		c->targetRot[0] = CLAMP(-180,c->targetRot[0],180);

		f32 vel = 0.05f;
		if (input->active_keys & KEY_SHIFT) vel = 0.3f;
		vel *= delta * 100.0;
		f32 forwardVel = 0.0f;
		
		if (input->active_keys & KEY_LEFT) {
			c->targetPos[0] += -c->dir[2] * vel;
			c->targetPos[2] += c->dir[0] * vel;
		};
		if (input->active_keys & KEY_RIGHT) {
			c->targetPos[0] -= -c->dir[2] * vel;
			c->targetPos[2] -= c->dir[0] * vel;
		};

		if (input->active_keys & KEY_JUMP) c->targetPos[1] += vel;
		if (input->active_keys & KEY_CROUCH) c->targetPos[1] -= vel;

		if (input->active_keys & KEY_UP) forwardVel -= vel;
		if (input->active_keys & KEY_DOWN) forwardVel += vel;

		c->targetPos[0] += c->dir[0] * forwardVel;
		c->targetPos[1] += c->dir[1] * forwardVel;
		c->targetPos[2] += c->dir[2] * forwardVel;
	}

	if (*active) {
		Vec3fApproach(node->rot, c->targetRot, (0.1/delta));
		Vec3fApproach(node->pos, c->targetPos, (0.1/delta));
	}
	
END_SCRIPT(free_camera)